// Embedded C tool wrappers for lemon and mkkeywordhash.
//
// These C programs are compiled into the synq-codegen binary with their
// main() renamed via -Dmain=lemon_main / -Dmain=mkkeywordhash_main.
// This module provides Zig-callable functions that capture their stdout.
//
// Each C tool call runs in a forked child process to isolate global state
// (lemon uses globals that can't be called twice) and to let exit() in
// lemon.c terminate just the child, not our main process.

const std = @import("std");
const mem = std.mem;
const fs = std.fs;
const posix = std.posix;
const Allocator = mem.Allocator;

// Extern declarations for the renamed C main functions.
extern fn lemon_main(argc: c_int, argv: [*]const [*:0]const u8) c_int;
extern fn mkkeywordhash_main(argc: c_int, argv: [*]const [*:0]const u8) c_int;

/// Stock lempar.c template, embedded at compile time.
/// Generated by build_synq_codegen.py into lempar_data.zig.
const lempar_data = @import("lempar_data.zig");
pub const lempar_c = lempar_data.data;

/// Run lemon with given arguments, capturing stdout to a buffer.
/// Returns the captured stdout content.
pub fn runLemonCapture(allocator: Allocator, argv_slices: []const []const u8) ![]u8 {
    return runCToolCapture(allocator, lemon_main, argv_slices);
}

/// Run lemon with given arguments (stdout goes to normal stdout).
/// Use this for commands that write to files (e.g., lemon -l parse.y).
pub fn runLemon(argv_slices: []const []const u8) !void {
    return runCTool(lemon_main, argv_slices);
}

/// Run mkkeywordhash, capturing stdout to a buffer.
/// Returns the captured stdout content.
pub fn runMkkeywordhash(allocator: Allocator) ![]u8 {
    return runCToolCapture(allocator, mkkeywordhash_main, &.{"mkkeywordhash"});
}

/// Run a C tool function, capturing its stdout to an allocated buffer.
fn runCToolCapture(
    allocator: Allocator,
    func: *const fn (c_int, [*]const [*:0]const u8) callconv(.c) c_int,
    argv_slices: []const []const u8,
) ![]u8 {
    // Create a temp file for capturing stdout
    var tmp_path_buf: [std.fs.max_path_bytes]u8 = undefined;
    const tmp_path = try makeTempPath(&tmp_path_buf);

    const tmp_file = try fs.cwd().createFile(tmp_path, .{});
    const tmp_fd = tmp_file.handle;

    // Save original stdout and redirect to temp file
    const saved_stdout = try posix.dup(posix.STDOUT_FILENO);
    try posix.dup2(tmp_fd, posix.STDOUT_FILENO);
    tmp_file.close(); // fd is now duped to stdout

    // Build null-terminated argv
    const c_argv = try buildCArgv(allocator, argv_slices);
    defer freeCArgv(allocator, c_argv, argv_slices.len);

    // Call the C function in a forked child
    try callCFuncForked(func, @intCast(argv_slices.len), c_argv.ptr);

    // Restore original stdout
    try posix.dup2(saved_stdout, posix.STDOUT_FILENO);
    posix.close(saved_stdout);

    // Read captured output
    const file = try fs.cwd().openFile(tmp_path, .{});
    defer file.close();
    defer fs.cwd().deleteFile(tmp_path) catch {};

    return try file.readToEndAlloc(allocator, 50 * 1024 * 1024);
}

/// Run a C tool function with normal stdout (for tools that write to files).
fn runCTool(
    func: *const fn (c_int, [*]const [*:0]const u8) callconv(.c) c_int,
    argv_slices: []const []const u8,
) !void {
    // Use a stack allocator for the argv construction
    var buf: [4096]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&buf);
    const allocator = fba.allocator();

    const c_argv = try buildCArgv(allocator, argv_slices);
    // No need to free with FBA

    try callCFuncForked(func, @intCast(argv_slices.len), c_argv.ptr);
}

/// Call a C main function in a forked child process.
/// The child inherits file descriptors (for stdout capture) and exits
/// with the return code. The parent waits and returns an error if non-zero.
fn callCFuncForked(
    func: *const fn (c_int, [*]const [*:0]const u8) callconv(.c) c_int,
    argc: c_int,
    argv: [*]const [*:0]const u8,
) !void {
    const pid = try posix.fork();

    if (pid == 0) {
        // Child process — call the C function and exit.
        // exit() is fine here (lemon calls it); it only terminates the child.
        const ret = func(argc, argv);
        std.process.exit(@intCast(@as(u32, @bitCast(ret))));
    }

    // Parent process — wait for child to finish.
    const result = posix.waitpid(pid, 0);
    if (result.status != 0) {
        return error.ToolFailed;
    }
}

const CArgv = struct {
    /// Pointer suitable for passing to C main(argc, argv).
    ptr: [*]const [*:0]const u8,
    /// Owned items (including the NULL terminator slot) for freeing.
    items: []?[*:0]const u8,
};

/// Build a C-compatible argv array from Zig slices.
fn buildCArgv(allocator: Allocator, argv_slices: []const []const u8) !CArgv {
    const items = try allocator.alloc(?[*:0]const u8, argv_slices.len + 1);
    for (argv_slices, 0..) |slice, i| {
        items[i] = try allocator.dupeZ(u8, slice);
    }
    items[argv_slices.len] = null; // NULL terminator
    return .{
        .ptr = @ptrCast(items.ptr),
        .items = items,
    };
}

fn freeCArgv(allocator: Allocator, argv: CArgv, len: usize) void {
    for (argv.items[0..len]) |maybe_ptr| {
        if (maybe_ptr) |ptr| {
            const slice = mem.span(ptr);
            allocator.free(slice[0 .. slice.len + 1]); // include the sentinel
        }
    }
    allocator.free(argv.items);
}

fn makeTempPath(buf: *[std.fs.max_path_bytes]u8) ![]const u8 {
    // Use /tmp with a unique name based on timestamp
    const timestamp = @as(u64, @intCast(std.time.nanoTimestamp()));
    return std.fmt.bufPrint(buf, "/tmp/synq-codegen-{d}.tmp", .{timestamp});
}
