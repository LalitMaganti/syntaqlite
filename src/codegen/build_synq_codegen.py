#!/usr/bin/env python3
# Copyright 2025 The syntaqlite Authors. All rights reserved.
# Licensed under the Apache License, Version 2.0.

"""Build the synq-codegen executable using zig build-exe.

GN action entry point. Invokes zig directly (no build.zig) to compile
src/main.zig into a standalone binary.
"""

import argparse
import os
import subprocess
import sys
from pathlib import Path

ROOT_DIR = Path(__file__).resolve().parent.parent.parent

sys.path.insert(0, str(ROOT_DIR))

from python.tools.run_third_party_binary import get_platform_dir


def _find_zig():
    os_dir, ext = get_platform_dir()
    if os_dir is None:
        print("OS not supported", file=sys.stderr)
        sys.exit(1)
    path = ROOT_DIR / "third_party" / "bin" / os_dir / ("zig" + ext)
    if not path.exists():
        print(f"zig not found: {path}", file=sys.stderr)
        print("Run tools/dev/install-build-deps to install build dependencies.",
              file=sys.stderr)
        sys.exit(1)
    return str(path)


def main():
    parser = argparse.ArgumentParser(description="Build synq-codegen via zig build-exe")
    parser.add_argument("--source", type=Path, required=True,
                        help="Path to main.zig root source file")
    parser.add_argument("--output", type=Path, required=True,
                        help="Path to output binary")
    parser.add_argument("--zig-cache", type=Path, required=True,
                        help="Zig local/global cache directory")
    args = parser.parse_args()

    source = args.source.resolve()
    output = args.output.resolve()
    cache = args.zig_cache.resolve()

    os.makedirs(output.parent, exist_ok=True)
    os.makedirs(cache, exist_ok=True)

    zig = _find_zig()

    # Compile embedded C tools (lemon.c and mkkeywordhash.c) as object files
    # with their main() renamed via -D to avoid symbol conflicts.
    sqlite_tool_dir = ROOT_DIR / "third_party" / "src" / "sqlite" / "tool"
    obj_dir = cache / "embedded-objs"
    os.makedirs(obj_dir, exist_ok=True)

    lemon_o = obj_dir / "lemon.o"
    mkkeywordhash_o = obj_dir / "mkkeywordhash.o"

    subprocess.check_call([
        zig, "cc", "-c",
        "-Dmain=lemon_main",
        str(sqlite_tool_dir / "lemon.c"),
        "-o", str(lemon_o),
    ])

    subprocess.check_call([
        zig, "cc", "-c",
        "-Dmain=mkkeywordhash_main",
        str(sqlite_tool_dir / "mkkeywordhash.c"),
        "-o", str(mkkeywordhash_o),
    ])

    # Generate lempar_data.zig with the embedded lempar.c template content.
    # This avoids @embedFile path restrictions by inlining the bytes at build time.
    lempar_c_path = sqlite_tool_dir / "lempar.c"
    lempar_data_zig = source.parent / "lempar_data.zig"
    lempar_bytes = lempar_c_path.read_bytes()
    with open(lempar_data_zig, "w") as f:
        f.write("// Auto-generated by build_synq_codegen.py â€” do not edit.\n")
        f.write("pub const data = &[_]u8{")
        for i, b in enumerate(lempar_bytes):
            if i % 16 == 0:
                f.write("\n   ")
            f.write(f" {b},")
        f.write("\n};\n")

    # Build the Zig binary, linking in the C object files
    subprocess.check_call([
        zig, "build-exe",
        str(source),
        str(lemon_o),
        str(mkkeywordhash_o),
        "-lc",
        "-O", "ReleaseSafe",
        "-femit-bin=" + str(output),
        "--cache-dir", str(cache),
        "--global-cache-dir", str(cache),
    ])

    return 0


if __name__ == "__main__":
    sys.exit(main())
